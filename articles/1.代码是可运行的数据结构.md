教学进展的方法：
    1. 类苏格拉底的对话交流，最佳情况是语音，受条件限制转为文本，这里用于预存大段文本
    2. 并不直接教授如何使用某个特性——那是 Google 做的事情，而是教你如何实现他（粗陋地，非工业可用）

lisp 使用代码与数据结构同形的语法，亦称 S-Expression，像这样：`(print "Hello World")`
这段代码可以在 Racket CS 8.4 运行，为什么特意声明这一点呢，因为 Lisp 的实现多如牛毛，从
Algol 60 到 Racket，每一门方言的标准库和实现细节迥然不同，因此请与我使用同样的实现。下载：[[https://download.racket-lang.org/]]
使用 Racket 的原因：具有一个合格的编辑器 DrRacket，具有内置的模式匹配（重要特性，虽然可以用宏自己实现但较难）

说回 S-Expression，其全称为 Symbolic Expression，与其说这是一种语法，不如说根本没设计任何语法，这就是代码的树表示本身。考虑 ``(+ 1 2) `` ，它把 1 和 2 相加，其中的 `+` ，`1` ，`2` 都是符号（Symbol），可以把他们想象为一种原子（Atom），不再可细分（忽略现实中的原子是可以细分的事实，这只是一个比喻），加号就是加号本身，作为一种标识符填充在列表中。这段代码不仅可以看作一段代码，同时也可以作为一个列表看待：一个第一项为加号，第二项为 `1`，第三项为 `2` 的列表。在没有对这个列表求值的时候，它仅仅是列表。这样同形的特性是 Lisp 系语言的重要特性，随之而来的是极为强力的宏（Macros），它可以接受 S-Expression 而生成 S-Expression，代码即是数据结构。这也是我选择 Racket 这门 Lisp 系语言来教学的重要原因。

## 引用 (Quote)

作为树的表达式需要和列表区分开来，我们需要使用一个特殊的函数来避免让表达式求值，也就是把他作为列表：`(quote (1 2))` Lisp 为我们提供了一个宏来代替 quote ，所以我们也可以写 `'(1 2)` 来返回这样的列表。有一个更加复杂的宏：QuasiQuote :  `<code>```</code>` （反撇号），它有许多高级的用法，但现在仅介绍一种：对于引用的列表部分地求值：

```
`(1 ,(2 3))
```

这会返回 '(1 5) ，也就是逗号后的表达式被引用时求值了。

## Macros

上文提到，Lisp 的代码是一种树结构，那么我们可以像操作数据结构一样操作代码。考虑以下的代码：

```
(define-syntax-rule
  (2sub (op e1 e2))
  (- e1 e2)
  )
(2sub (+ 1 2))
```

我们使用 define-syntax-rule 来定义了一个宏，这个宏匹配了 (操作符 操作数1 操作数2) 的结构，并且输出 (- 操作数1 操作数2) 作为返回值，并且被立即求值，得到结果 -1。
宏和普通函数的区别是：宏会自动按照模式匹配其参数，并且参数传入时不求值（被 Quote），因此我们可以任意变换代码。

## 生活在树上

Lisp 系的语言的表达式不仅是树，还是二叉树。任何多叉树都是用二叉树模拟的，或者可以说是二元组。二元组是 Lisp 系语言中事实上唯一的数据结构。
我们可以使用 cons （即 Construct ）函数来把两个元素结合为一个二元组。考虑如下代码（分号表示注释）：

```
(cons 1 2)      ;返回 '(1 2)
(cons 1 '(2 3)) ;返回 '(1 2 3)
```

可以看到， `(1 2 3)` 事实上是 `(1 (2 3))` ，本质上是二叉树。

我们还可以使用 `car` ('Contents of the Address part of the Register') 和 `cdr` ('Contents of the Decrement part of the Register') 来操作二叉树。`car` 取二叉树的 `head` ，`cdr` 取二叉树的 `tail` 。
关于它们的组合版本 `cadr` 可以做什么，你可以自己想象。

```
(car '(1 2 3))  ;返回 1
(car '((1 2) 3) ;返回 '(1 2)
(cdr '(1 2 3))  ;返回 '(2 3)
(cdr '((1 2) 3) ;返回 3
(cadr '(1 2 3)) ;返回 2
```

我们可以使用二元组构建诸如链表之类的结构

```
(define linked-list
   '(1 (2 (3 (4 (5)))))
)
(cadr (cadr (cadr (cadr linked-list)))) ;因为直接 cdr 会返回类似 ((2 3 4 5)) 之类的元组中的元组，所以我们不得不用 cadr 来 workaround，这个表达式返回 5
```

SCIP 里面有一张很形象的图来表示用二元组构成的二叉树结构：

![[OIP-C.jpg]]

这是测试文本，这是测试文本，这是测试文本，这是测试文本，这是测试文本，这是测试文本，这是测试文本，这是测试文本，这是测试文本，这是测试文本，这是测试文本，这是测试文本，这是测试文本，这是测试文本，这是测试文本，这是测试文本，这是测试文本，
