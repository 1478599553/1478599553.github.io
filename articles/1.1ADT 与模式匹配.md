ADT （Algebraic Data Type）是一种有意思的数据抽象方式。不同于 Java 的基于子类型多态的面向对象式抽象，ADT 使用 和类型（Sum Type） 与积类型 (Product Type) 来组织数据。
本节笔者本来使用 OCaml 这门 ML (Meta Language, 1970s ) 系的语言来讲解 ADT，但因为 OCaml 的编译器工具链在 Windows 和 Armv7 linux（笔者的树莓派） 下体验相当糟糕，所以我们使用 OCaml 在 .NET 6 下的方言实现：F#。F# 安装过程十分简单，安装 .NET 6 （或者更新的版本），然后运行如下命令：
`dotnet new console -lang F# -o <你的项目名字> -f net6.0` ，然后使用 VSCode 打开项目，别忘记给你的 VSCode 安装一个 F# 的插件。

### 前置知识：表达式 (Expression)
ML 系语言是基于表达式的，这给予它高度的灵活性。表达式必须返回一个值，因此它可以用来替换任何一个与其返回值相同类型的值。比如 `if then else` 是一个表达式，那么我们可以把它放在 `let` 语句中：
```
let test_var = if true then 1 else 2;;
```
你需要在表达式末尾加上 `;;` 来结束它，加上 `;` 可用于显式分开表达式块的各个表达式，当然也可以不加。表达式块可以用来表达一个较小的作用域，返回值是其最后一条表达式：
```
let exps =
    let test_var1 = if true then 1 else 2;
    let test_var2 = if true then 1 else 2;
    test_var1 + test_var2;;                   // 出了表达式块则不能使用 test_var1 等变量
```
但是任何东西都是过犹不及的，ML 为了语义的统一性，本来应该是语句的动作现在会产生一个空元组（即 "()"）作为返回值，在 F# 的 REPL （Read & Evaluate & Print Loop，可以理解为交互式的命令行环境）输入下面的“表达式”，我们得到：
```
> let y = printfn "%d" 1;;          //下面两行是输出
1                                   //我们打印了 “1”
val y: unit = ()                    //显示 y 的类型是 unit，值为空元组
```
这样的代码能通过编译本身是不优雅的，我们得到一个毫无意义的空元组却不报错，这埋下一个隐患。所幸 F# 自带的表达式 `let` 不能用于赋值一个变量，编译器在这一点上做对了。

### 和类型

考虑下面的 F# 代码：
```
type string_or_int = StringType of string | IntType of int;;
let test  = IntType(42);;
```
我们定义了一个叫做 `string_or_int` 的类型，它表示自身要么是一个带有 `string` 类型的值的 `StringType` ，要么是一个带有 `int` 类型的值的 `IntType` 。我们可以使用 `IntType` 这个构造器来产生一个带有 `int` 值 `42` 的 `string_or_int` 类型变量（虽然它事实上不可变），然后用 F# 的模式匹配语法把他绑定到了 `test` 上。

### 积类型

```
type Pairs = I32 of (int32 * int32) | I64 of (int64 * int64);;
let x = I32(1,2);;
```
一个指定各项的类型的元组。


## 模式匹配

模式匹配是一种用于解构数据结构的操作：
```
let (a,b) = (1,2);; // a = 1,b = 2
```
此时我们按照元组 `(1,2)` 的各项的结构构造了一个模式 `(a,b)`，那么 `a` 和 `b` 就会被绑定对应位置的值。
我们还有更复杂的多从句模式匹配：
```
let res = 
	match x with
	| I32 (a,b) -> a+b
	| I64 (a,b) -> a+b;;

let head list =                         
    match list with
    | head::tail -> printfn "%d" head;; // "::"是Cons操作符，把列表用头尾Cons的形式表示

head (2::[1;2]);;                       // 2::[1;2] 等价于 [2;1;2]
```
于是我们可以用这样的模式匹配来提取列表元素：
```
let rec decons_list list =          // let rec 定义了递归函数
    match list with
    | head::tail ->
            printfn "%d" head;
            decons_list tail
    | [] -> printfn "finished";;

decons_list [1;2;3;4];;
```
关于剩下的模式，可以参考 [MS 的文档 模式匹配 - F# | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/fsharp/language-reference/pattern-matching) 。

使用 ADT 与模式匹配，我们可以十分快速地构造递归的数据结构，比如链表：
```
let linked_list_1 = Node(1,Node(2,Node(3,None)));;

let rec decons_linked_list list =
    match list with
    | Node(value, next) ->
        printfn "%d" value;
        decons_linked_list next
    | None -> printfn "%s" "finished" ;;

decons_linked_list linked_list_1;;

(*
输出：
	1
	2
	3
	finished
*)                               // 用 (*  *) 来表示多行注释
```
这样的结构我们以后在解释器中会用来抽象我们的语法树结构。